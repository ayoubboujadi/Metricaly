/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.8.2.0 (NJsonSchema v10.2.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAuthClient {
    signUp(registerCommand: RegisterCommand): Observable<FileResponse | null>;
    signIn(authenticateCommand: AuthenticateCommand): Observable<AuthenticatedDto>;
}

@Injectable({
    providedIn: 'root'
})
export class AuthClient implements IAuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    signUp(registerCommand: RegisterCommand): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Auth/signup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignUp(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processSignUp(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    signIn(authenticateCommand: AuthenticateCommand): Observable<AuthenticatedDto> {
        let url_ = this.baseUrl + "/api/Auth/signin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(authenticateCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignIn(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticatedDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticatedDto>><any>_observableThrow(response_);
        }));
    }

    protected processSignIn(response: HttpResponseBase): Observable<AuthenticatedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticatedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticatedDto>(<any>null);
    }
}

export interface IMetricClient {
    getMetricValues(request: GetMetricTimeSeriesQuery): Observable<MetricsTimeSeriesResultDto>;
    listMetrics(applicationId: string): Observable<MetricDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class MetricClient implements IMetricClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getMetricValues(request: GetMetricTimeSeriesQuery): Observable<MetricsTimeSeriesResultDto> {
        let url_ = this.baseUrl + "/Metric/query";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMetricValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMetricValues(<any>response_);
                } catch (e) {
                    return <Observable<MetricsTimeSeriesResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MetricsTimeSeriesResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMetricValues(response: HttpResponseBase): Observable<MetricsTimeSeriesResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MetricsTimeSeriesResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MetricsTimeSeriesResultDto>(<any>null);
    }

    listMetrics(applicationId: string): Observable<MetricDto[]> {
        let url_ = this.baseUrl + "/Metric/{applicationId}/metrics";
        if (applicationId === undefined || applicationId === null)
            throw new Error("The parameter 'applicationId' must be defined.");
        url_ = url_.replace("{applicationId}", encodeURIComponent("" + applicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListMetrics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListMetrics(<any>response_);
                } catch (e) {
                    return <Observable<MetricDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MetricDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processListMetrics(response: HttpResponseBase): Observable<MetricDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MetricDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MetricDto[]>(<any>null);
    }
}

export interface IApplicationClient {
    list(): Observable<ApplicationDto[]>;
    create(createApplicationCommand: CreateApplicationCommand): Observable<FileResponse | null>;
}

@Injectable({
    providedIn: 'root'
})
export class ApplicationClient implements IApplicationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    list(): Observable<ApplicationDto[]> {
        let url_ = this.baseUrl + "/api/Application";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processList(response: HttpResponseBase): Observable<ApplicationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ApplicationDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationDto[]>(<any>null);
    }

    create(createApplicationCommand: CreateApplicationCommand): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Application";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createApplicationCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }
}

export interface IDashboardClient {
    create(command: CreateDashboardCommand): Observable<string>;
    update(command: UpdateDashboardCommand): Observable<FileResponse | null>;
    get(dashboardId: string): Observable<DashboardDetailsVm>;
    list(applicationId: string): Observable<DashboardDto[]>;
    delete(dashboardId: string): Observable<FileResponse | null>;
    getFavoriteList(): Observable<DashboardDto[]>;
    addFavorite(command: FavoriteDashboardCommand): Observable<FileResponse | null>;
}

@Injectable({
    providedIn: 'root'
})
export class DashboardClient implements IDashboardClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(command: CreateDashboardCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Dashboard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    update(command: UpdateDashboardCommand): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Dashboard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    get(dashboardId: string): Observable<DashboardDetailsVm> {
        let url_ = this.baseUrl + "/api/Dashboard/get/{dashboardId}";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DashboardDetailsVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<DashboardDetailsVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DashboardDetailsVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardDetailsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardDetailsVm>(<any>null);
    }

    list(applicationId: string): Observable<DashboardDto[]> {
        let url_ = this.baseUrl + "/api/Dashboard/list/{applicationId}";
        if (applicationId === undefined || applicationId === null)
            throw new Error("The parameter 'applicationId' must be defined.");
        url_ = url_.replace("{applicationId}", encodeURIComponent("" + applicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(<any>response_);
                } catch (e) {
                    return <Observable<DashboardDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DashboardDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processList(response: HttpResponseBase): Observable<DashboardDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DashboardDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardDto[]>(<any>null);
    }

    delete(dashboardId: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Dashboard/{dashboardId}";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    getFavoriteList(): Observable<DashboardDto[]> {
        let url_ = this.baseUrl + "/api/Dashboard/get/favorite";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFavoriteList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFavoriteList(<any>response_);
                } catch (e) {
                    return <Observable<DashboardDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DashboardDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFavoriteList(response: HttpResponseBase): Observable<DashboardDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DashboardDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardDto[]>(<any>null);
    }

    addFavorite(command: FavoriteDashboardCommand): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Dashboard/add/favorite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddFavorite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddFavorite(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processAddFavorite(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }
}

export interface IWidgetClient {
    create(request: CreateWidgetCommand): Observable<string>;
    list(applicationId: string): Observable<WidgetDto[]>;
    getWidget(widgetId: string): Observable<WidgetDto>;
}

@Injectable({
    providedIn: 'root'
})
export class WidgetClient implements IWidgetClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(request: CreateWidgetCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Widget";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    list(applicationId: string): Observable<WidgetDto[]> {
        let url_ = this.baseUrl + "/api/Widget/list/{applicationId}";
        if (applicationId === undefined || applicationId === null)
            throw new Error("The parameter 'applicationId' must be defined.");
        url_ = url_.replace("{applicationId}", encodeURIComponent("" + applicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(<any>response_);
                } catch (e) {
                    return <Observable<WidgetDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WidgetDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processList(response: HttpResponseBase): Observable<WidgetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WidgetDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WidgetDto[]>(<any>null);
    }

    getWidget(widgetId: string): Observable<WidgetDto> {
        let url_ = this.baseUrl + "/api/Widget/type/{widgetId}";
        if (widgetId === undefined || widgetId === null)
            throw new Error("The parameter 'widgetId' must be defined.");
        url_ = url_.replace("{widgetId}", encodeURIComponent("" + widgetId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWidget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWidget(<any>response_);
                } catch (e) {
                    return <Observable<WidgetDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WidgetDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWidget(response: HttpResponseBase): Observable<WidgetDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WidgetDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WidgetDto>(<any>null);
    }
}

export interface ILineChartWidgetClient {
    update(requestData: UpdateWidgetCommandOfLineChartWidget): Observable<FileResponse | null>;
    get(widgetId: string): Observable<WidgetDetailsVmOfLineChartWidget>;
    readMultiple(widgetIds: string[]): Observable<WidgetDetailsVmOfLineChartWidget[]>;
}

@Injectable({
    providedIn: 'root'
})
export class LineChartWidgetClient implements ILineChartWidgetClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    update(requestData: UpdateWidgetCommandOfLineChartWidget): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/LineChartWidget";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    get(widgetId: string): Observable<WidgetDetailsVmOfLineChartWidget> {
        let url_ = this.baseUrl + "/api/LineChartWidget/get/{widgetId}";
        if (widgetId === undefined || widgetId === null)
            throw new Error("The parameter 'widgetId' must be defined.");
        url_ = url_.replace("{widgetId}", encodeURIComponent("" + widgetId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WidgetDetailsVmOfLineChartWidget>><any>_observableThrow(e);
                }
            } else
                return <Observable<WidgetDetailsVmOfLineChartWidget>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WidgetDetailsVmOfLineChartWidget> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WidgetDetailsVmOfLineChartWidget.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WidgetDetailsVmOfLineChartWidget>(<any>null);
    }

    readMultiple(widgetIds: string[]): Observable<WidgetDetailsVmOfLineChartWidget[]> {
        let url_ = this.baseUrl + "/api/LineChartWidget/get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(widgetIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadMultiple(<any>response_);
                } catch (e) {
                    return <Observable<WidgetDetailsVmOfLineChartWidget[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WidgetDetailsVmOfLineChartWidget[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadMultiple(response: HttpResponseBase): Observable<WidgetDetailsVmOfLineChartWidget[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WidgetDetailsVmOfLineChartWidget.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WidgetDetailsVmOfLineChartWidget[]>(<any>null);
    }
}

export class RegisterCommand implements IRegisterCommand {
    email?: string | undefined;
    name?: string | undefined;
    password?: string | undefined;

    constructor(data?: IRegisterCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.name = _data["name"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["name"] = this.name;
        data["password"] = this.password;
        return data; 
    }
}

export interface IRegisterCommand {
    email?: string | undefined;
    name?: string | undefined;
    password?: string | undefined;
}

export class AuthenticatedDto implements IAuthenticatedDto {
    token?: string | undefined;
    userId?: string | undefined;
    userEmail?: string | undefined;

    constructor(data?: IAuthenticatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.userId = _data["userId"];
            this.userEmail = _data["userEmail"];
        }
    }

    static fromJS(data: any): AuthenticatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["userId"] = this.userId;
        data["userEmail"] = this.userEmail;
        return data; 
    }
}

export interface IAuthenticatedDto {
    token?: string | undefined;
    userId?: string | undefined;
    userEmail?: string | undefined;
}

export class AuthenticateCommand implements IAuthenticateCommand {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: IAuthenticateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthenticateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data; 
    }
}

export interface IAuthenticateCommand {
    email?: string | undefined;
    password?: string | undefined;
}

export class MetricsTimeSeriesResultDto implements IMetricsTimeSeriesResultDto {
    samplingValue!: number;
    count!: number;
    timestamps?: number[] | undefined;
    values?: MetricTimeSeriesValueDto[] | undefined;

    constructor(data?: IMetricsTimeSeriesResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.samplingValue = _data["samplingValue"];
            this.count = _data["count"];
            if (Array.isArray(_data["timestamps"])) {
                this.timestamps = [] as any;
                for (let item of _data["timestamps"])
                    this.timestamps!.push(item);
            }
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(MetricTimeSeriesValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MetricsTimeSeriesResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MetricsTimeSeriesResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["samplingValue"] = this.samplingValue;
        data["count"] = this.count;
        if (Array.isArray(this.timestamps)) {
            data["timestamps"] = [];
            for (let item of this.timestamps)
                data["timestamps"].push(item);
        }
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMetricsTimeSeriesResultDto {
    samplingValue: number;
    count: number;
    timestamps?: number[] | undefined;
    values?: MetricTimeSeriesValueDto[] | undefined;
}

export class MetricTimeSeriesValueDto implements IMetricTimeSeriesValueDto {
    guid?: string | undefined;
    metricName?: string | undefined;
    namespace?: string | undefined;
    values?: number[] | undefined;

    constructor(data?: IMetricTimeSeriesValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.metricName = _data["metricName"];
            this.namespace = _data["namespace"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): MetricTimeSeriesValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new MetricTimeSeriesValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["metricName"] = this.metricName;
        data["namespace"] = this.namespace;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data; 
    }
}

export interface IMetricTimeSeriesValueDto {
    guid?: string | undefined;
    metricName?: string | undefined;
    namespace?: string | undefined;
    values?: number[] | undefined;
}

export class GetMetricTimeSeriesQuery implements IGetMetricTimeSeriesQuery {
    startTimestamp!: number;
    endTimestamp?: number | undefined;
    samplingTime!: number;
    applicationId!: string;
    metrics?: MetricNamespaceDTO[] | undefined;

    constructor(data?: IGetMetricTimeSeriesQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startTimestamp = _data["startTimestamp"];
            this.endTimestamp = _data["endTimestamp"];
            this.samplingTime = _data["samplingTime"];
            this.applicationId = _data["applicationId"];
            if (Array.isArray(_data["metrics"])) {
                this.metrics = [] as any;
                for (let item of _data["metrics"])
                    this.metrics!.push(MetricNamespaceDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMetricTimeSeriesQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetMetricTimeSeriesQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTimestamp"] = this.startTimestamp;
        data["endTimestamp"] = this.endTimestamp;
        data["samplingTime"] = this.samplingTime;
        data["applicationId"] = this.applicationId;
        if (Array.isArray(this.metrics)) {
            data["metrics"] = [];
            for (let item of this.metrics)
                data["metrics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetMetricTimeSeriesQuery {
    startTimestamp: number;
    endTimestamp?: number | undefined;
    samplingTime: number;
    applicationId: string;
    metrics?: MetricNamespaceDTO[] | undefined;
}

export class MetricNamespaceDTO implements IMetricNamespaceDTO {
    guid?: string | undefined;
    metricName?: string | undefined;
    namespace?: string | undefined;
    samplingType!: SamplingType;

    constructor(data?: IMetricNamespaceDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.metricName = _data["metricName"];
            this.namespace = _data["namespace"];
            this.samplingType = _data["samplingType"];
        }
    }

    static fromJS(data: any): MetricNamespaceDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MetricNamespaceDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["metricName"] = this.metricName;
        data["namespace"] = this.namespace;
        data["samplingType"] = this.samplingType;
        return data; 
    }
}

export interface IMetricNamespaceDTO {
    guid?: string | undefined;
    metricName?: string | undefined;
    namespace?: string | undefined;
    samplingType: SamplingType;
}

export enum SamplingType {
    Average = "Average",
    Sum = "Sum",
    Min = "Min",
    Max = "Max",
    SimpleCount = "SimpleCount",
}

export class MetricDto implements IMetricDto {
    name?: string | undefined;
    namespace?: string | undefined;
    applicationId!: string;
    id!: string;

    constructor(data?: IMetricDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.namespace = _data["namespace"];
            this.applicationId = _data["applicationId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MetricDto {
        data = typeof data === 'object' ? data : {};
        let result = new MetricDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["namespace"] = this.namespace;
        data["applicationId"] = this.applicationId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMetricDto {
    name?: string | undefined;
    namespace?: string | undefined;
    applicationId: string;
    id: string;
}

export class ApplicationDto implements IApplicationDto {
    id?: string | undefined;
    name?: string | undefined;
    apiKey?: string | undefined;
    obfuscatedApiKey?: string | undefined;

    constructor(data?: IApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.apiKey = _data["apiKey"];
            this.obfuscatedApiKey = _data["obfuscatedApiKey"];
        }
    }

    static fromJS(data: any): ApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["apiKey"] = this.apiKey;
        data["obfuscatedApiKey"] = this.obfuscatedApiKey;
        return data; 
    }
}

export interface IApplicationDto {
    id?: string | undefined;
    name?: string | undefined;
    apiKey?: string | undefined;
    obfuscatedApiKey?: string | undefined;
}

export class CreateApplicationCommand implements ICreateApplicationCommand {
    applicationName?: string | undefined;

    constructor(data?: ICreateApplicationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationName = _data["applicationName"];
        }
    }

    static fromJS(data: any): CreateApplicationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApplicationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationName"] = this.applicationName;
        return data; 
    }
}

export interface ICreateApplicationCommand {
    applicationName?: string | undefined;
}

export class CreateDashboardCommand implements ICreateDashboardCommand {
    applicationId!: string;
    dashboardName?: string | undefined;

    constructor(data?: ICreateDashboardCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationId = _data["applicationId"];
            this.dashboardName = _data["dashboardName"];
        }
    }

    static fromJS(data: any): CreateDashboardCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDashboardCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationId"] = this.applicationId;
        data["dashboardName"] = this.dashboardName;
        return data; 
    }
}

export interface ICreateDashboardCommand {
    applicationId: string;
    dashboardName?: string | undefined;
}

export class UpdateDashboardCommand implements IUpdateDashboardCommand {
    dashboardId!: string;
    applicationId!: string;
    dashboardWidgets?: DashboardWidget[] | undefined;

    constructor(data?: IUpdateDashboardCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardId = _data["dashboardId"];
            this.applicationId = _data["applicationId"];
            if (Array.isArray(_data["dashboardWidgets"])) {
                this.dashboardWidgets = [] as any;
                for (let item of _data["dashboardWidgets"])
                    this.dashboardWidgets!.push(DashboardWidget.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateDashboardCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDashboardCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardId"] = this.dashboardId;
        data["applicationId"] = this.applicationId;
        if (Array.isArray(this.dashboardWidgets)) {
            data["dashboardWidgets"] = [];
            for (let item of this.dashboardWidgets)
                data["dashboardWidgets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateDashboardCommand {
    dashboardId: string;
    applicationId: string;
    dashboardWidgets?: DashboardWidget[] | undefined;
}

export class BaseEntity implements IBaseEntity {
    id!: string;
    createdDate!: Date;

    constructor(data?: IBaseEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseEntity {
        data = typeof data === 'object' ? data : {};
        let result = new BaseEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IBaseEntity {
    id: string;
    createdDate: Date;
}

export class DashboardWidget extends BaseEntity implements IDashboardWidget {
    width!: number;
    height!: number;
    x!: number;
    y!: number;
    dashboardId!: string;
    dashboard?: Dashboard | undefined;
    widgetId!: string;
    widget?: Widget | undefined;

    constructor(data?: IDashboardWidget) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.width = _data["width"];
            this.height = _data["height"];
            this.x = _data["x"];
            this.y = _data["y"];
            this.dashboardId = _data["dashboardId"];
            this.dashboard = _data["dashboard"] ? Dashboard.fromJS(_data["dashboard"]) : <any>undefined;
            this.widgetId = _data["widgetId"];
            this.widget = _data["widget"] ? Widget.fromJS(_data["widget"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DashboardWidget {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardWidget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        data["x"] = this.x;
        data["y"] = this.y;
        data["dashboardId"] = this.dashboardId;
        data["dashboard"] = this.dashboard ? this.dashboard.toJSON() : <any>undefined;
        data["widgetId"] = this.widgetId;
        data["widget"] = this.widget ? this.widget.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IDashboardWidget extends IBaseEntity {
    width: number;
    height: number;
    x: number;
    y: number;
    dashboardId: string;
    dashboard?: Dashboard | undefined;
    widgetId: string;
    widget?: Widget | undefined;
}

export class Dashboard extends BaseEntity implements IDashboard {
    name?: string | undefined;
    applicationId!: string;
    isFavorite!: boolean;
    dashboardWidgets?: DashboardWidget[] | undefined;

    constructor(data?: IDashboard) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.applicationId = _data["applicationId"];
            this.isFavorite = _data["isFavorite"];
            if (Array.isArray(_data["dashboardWidgets"])) {
                this.dashboardWidgets = [] as any;
                for (let item of _data["dashboardWidgets"])
                    this.dashboardWidgets!.push(DashboardWidget.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Dashboard {
        data = typeof data === 'object' ? data : {};
        let result = new Dashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["applicationId"] = this.applicationId;
        data["isFavorite"] = this.isFavorite;
        if (Array.isArray(this.dashboardWidgets)) {
            data["dashboardWidgets"] = [];
            for (let item of this.dashboardWidgets)
                data["dashboardWidgets"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IDashboard extends IBaseEntity {
    name?: string | undefined;
    applicationId: string;
    isFavorite: boolean;
    dashboardWidgets?: DashboardWidget[] | undefined;
}

export class Widget extends BaseEntity implements IWidget {
    name?: string | undefined;
    type?: string | undefined;
    data?: string | undefined;
    applicationId!: string;

    constructor(data?: IWidget) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            this.data = _data["data"];
            this.applicationId = _data["applicationId"];
        }
    }

    static fromJS(data: any): Widget {
        data = typeof data === 'object' ? data : {};
        let result = new Widget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["data"] = this.data;
        data["applicationId"] = this.applicationId;
        super.toJSON(data);
        return data; 
    }
}

export interface IWidget extends IBaseEntity {
    name?: string | undefined;
    type?: string | undefined;
    data?: string | undefined;
    applicationId: string;
}

export class DashboardDetailsVm implements IDashboardDetailsVm {
    dashboard?: DashboardDto | undefined;
    dashboardWidgets?: DashboardWidgetDto[] | undefined;

    constructor(data?: IDashboardDetailsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboard = _data["dashboard"] ? DashboardDto.fromJS(_data["dashboard"]) : <any>undefined;
            if (Array.isArray(_data["dashboardWidgets"])) {
                this.dashboardWidgets = [] as any;
                for (let item of _data["dashboardWidgets"])
                    this.dashboardWidgets!.push(DashboardWidgetDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboardDetailsVm {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardDetailsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboard"] = this.dashboard ? this.dashboard.toJSON() : <any>undefined;
        if (Array.isArray(this.dashboardWidgets)) {
            data["dashboardWidgets"] = [];
            for (let item of this.dashboardWidgets)
                data["dashboardWidgets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDashboardDetailsVm {
    dashboard?: DashboardDto | undefined;
    dashboardWidgets?: DashboardWidgetDto[] | undefined;
}

export class DashboardDto implements IDashboardDto {
    applicationId!: string;
    id!: string;
    name?: string | undefined;
    createdDate!: Date;
    isFavorite!: boolean;
    dashboardWidgetsCount!: number;

    constructor(data?: IDashboardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationId = _data["applicationId"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.isFavorite = _data["isFavorite"];
            this.dashboardWidgetsCount = _data["dashboardWidgetsCount"];
        }
    }

    static fromJS(data: any): DashboardDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationId"] = this.applicationId;
        data["id"] = this.id;
        data["name"] = this.name;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["isFavorite"] = this.isFavorite;
        data["dashboardWidgetsCount"] = this.dashboardWidgetsCount;
        return data; 
    }
}

export interface IDashboardDto {
    applicationId: string;
    id: string;
    name?: string | undefined;
    createdDate: Date;
    isFavorite: boolean;
    dashboardWidgetsCount: number;
}

export class DashboardWidgetDto implements IDashboardWidgetDto {
    width!: number;
    height!: number;
    x!: number;
    y!: number;
    widgetId!: string;
    widgetType?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDashboardWidgetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.width = _data["width"];
            this.height = _data["height"];
            this.x = _data["x"];
            this.y = _data["y"];
            this.widgetId = _data["widgetId"];
            this.widgetType = _data["widgetType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DashboardWidgetDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardWidgetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        data["x"] = this.x;
        data["y"] = this.y;
        data["widgetId"] = this.widgetId;
        data["widgetType"] = this.widgetType;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDashboardWidgetDto {
    width: number;
    height: number;
    x: number;
    y: number;
    widgetId: string;
    widgetType?: string | undefined;
    id?: string | undefined;
}

export class FavoriteDashboardCommand implements IFavoriteDashboardCommand {
    dashboardId!: string;
    isFavorite!: boolean;

    constructor(data?: IFavoriteDashboardCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardId = _data["dashboardId"];
            this.isFavorite = _data["isFavorite"];
        }
    }

    static fromJS(data: any): FavoriteDashboardCommand {
        data = typeof data === 'object' ? data : {};
        let result = new FavoriteDashboardCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardId"] = this.dashboardId;
        data["isFavorite"] = this.isFavorite;
        return data; 
    }
}

export interface IFavoriteDashboardCommand {
    dashboardId: string;
    isFavorite: boolean;
}

export class CreateWidgetCommand implements ICreateWidgetCommand {
    applicationId!: string;
    name?: string | undefined;
    widgetType!: WidgetType;

    constructor(data?: ICreateWidgetCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationId = _data["applicationId"];
            this.name = _data["name"];
            this.widgetType = _data["widgetType"];
        }
    }

    static fromJS(data: any): CreateWidgetCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWidgetCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationId"] = this.applicationId;
        data["name"] = this.name;
        data["widgetType"] = this.widgetType;
        return data; 
    }
}

export interface ICreateWidgetCommand {
    applicationId: string;
    name?: string | undefined;
    widgetType: WidgetType;
}

export enum WidgetType {
    LineChart = "LineChart",
}

export class WidgetDto implements IWidgetDto {
    applicationId!: string;
    id!: string;
    name?: string | undefined;
    type?: string | undefined;
    createdDate!: Date;

    constructor(data?: IWidgetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationId = _data["applicationId"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WidgetDto {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationId"] = this.applicationId;
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IWidgetDto {
    applicationId: string;
    id: string;
    name?: string | undefined;
    type?: string | undefined;
    createdDate: Date;
}

export class UpdateWidgetCommandOfLineChartWidget implements IUpdateWidgetCommandOfLineChartWidget {
    id!: string;
    name?: string | undefined;
    widgetData?: LineChartWidget | undefined;

    constructor(data?: IUpdateWidgetCommandOfLineChartWidget) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.widgetData = _data["widgetData"] ? LineChartWidget.fromJS(_data["widgetData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateWidgetCommandOfLineChartWidget {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWidgetCommandOfLineChartWidget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["widgetData"] = this.widgetData ? this.widgetData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUpdateWidgetCommandOfLineChartWidget {
    id: string;
    name?: string | undefined;
    widgetData?: LineChartWidget | undefined;
}

export class WidgetData implements IWidgetData {
    title?: string | undefined;

    constructor(data?: IWidgetData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): WidgetData {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data; 
    }
}

export interface IWidgetData {
    title?: string | undefined;
}

export class LineChartWidget extends WidgetData implements ILineChartWidget {
    samplingTime!: number;
    plottedMetrics?: LineChartPlottedMetric[] | undefined;
    widgetSettings?: LineChartWidgetSettings | undefined;

    constructor(data?: ILineChartWidget) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.samplingTime = _data["samplingTime"];
            if (Array.isArray(_data["plottedMetrics"])) {
                this.plottedMetrics = [] as any;
                for (let item of _data["plottedMetrics"])
                    this.plottedMetrics!.push(LineChartPlottedMetric.fromJS(item));
            }
            this.widgetSettings = _data["widgetSettings"] ? LineChartWidgetSettings.fromJS(_data["widgetSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LineChartWidget {
        data = typeof data === 'object' ? data : {};
        let result = new LineChartWidget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["samplingTime"] = this.samplingTime;
        if (Array.isArray(this.plottedMetrics)) {
            data["plottedMetrics"] = [];
            for (let item of this.plottedMetrics)
                data["plottedMetrics"].push(item.toJSON());
        }
        data["widgetSettings"] = this.widgetSettings ? this.widgetSettings.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface ILineChartWidget extends IWidgetData {
    samplingTime: number;
    plottedMetrics?: LineChartPlottedMetric[] | undefined;
    widgetSettings?: LineChartWidgetSettings | undefined;
}

export class LineChartPlottedMetric implements ILineChartPlottedMetric {
    metricId!: number;
    guid?: string | undefined;
    label?: string | undefined;
    color?: string | undefined;
    metricName?: string | undefined;
    namespace?: string | undefined;
    yAxis?: string | undefined;
    samplingType?: string | undefined;

    constructor(data?: ILineChartPlottedMetric) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.metricId = _data["metricId"];
            this.guid = _data["guid"];
            this.label = _data["label"];
            this.color = _data["color"];
            this.metricName = _data["metricName"];
            this.namespace = _data["namespace"];
            this.yAxis = _data["yAxis"];
            this.samplingType = _data["samplingType"];
        }
    }

    static fromJS(data: any): LineChartPlottedMetric {
        data = typeof data === 'object' ? data : {};
        let result = new LineChartPlottedMetric();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["metricId"] = this.metricId;
        data["guid"] = this.guid;
        data["label"] = this.label;
        data["color"] = this.color;
        data["metricName"] = this.metricName;
        data["namespace"] = this.namespace;
        data["yAxis"] = this.yAxis;
        data["samplingType"] = this.samplingType;
        return data; 
    }
}

export interface ILineChartPlottedMetric {
    metricId: number;
    guid?: string | undefined;
    label?: string | undefined;
    color?: string | undefined;
    metricName?: string | undefined;
    namespace?: string | undefined;
    yAxis?: string | undefined;
    samplingType?: string | undefined;
}

export class LineChartWidgetSettings implements ILineChartWidgetSettings {
    title?: string | undefined;
    legendPosition?: string | undefined;
    displayLegend!: boolean;
    smoothLines!: boolean;
    filled!: boolean;
    xAxisSettings?: LineChartAxisSettings | undefined;
    yLeftAxisSettings?: LineChartAxisSettings | undefined;
    yRightAxisSettings?: LineChartAxisSettings | undefined;

    constructor(data?: ILineChartWidgetSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.legendPosition = _data["legendPosition"];
            this.displayLegend = _data["displayLegend"];
            this.smoothLines = _data["smoothLines"];
            this.filled = _data["filled"];
            this.xAxisSettings = _data["xAxisSettings"] ? LineChartAxisSettings.fromJS(_data["xAxisSettings"]) : <any>undefined;
            this.yLeftAxisSettings = _data["yLeftAxisSettings"] ? LineChartAxisSettings.fromJS(_data["yLeftAxisSettings"]) : <any>undefined;
            this.yRightAxisSettings = _data["yRightAxisSettings"] ? LineChartAxisSettings.fromJS(_data["yRightAxisSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LineChartWidgetSettings {
        data = typeof data === 'object' ? data : {};
        let result = new LineChartWidgetSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["legendPosition"] = this.legendPosition;
        data["displayLegend"] = this.displayLegend;
        data["smoothLines"] = this.smoothLines;
        data["filled"] = this.filled;
        data["xAxisSettings"] = this.xAxisSettings ? this.xAxisSettings.toJSON() : <any>undefined;
        data["yLeftAxisSettings"] = this.yLeftAxisSettings ? this.yLeftAxisSettings.toJSON() : <any>undefined;
        data["yRightAxisSettings"] = this.yRightAxisSettings ? this.yRightAxisSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ILineChartWidgetSettings {
    title?: string | undefined;
    legendPosition?: string | undefined;
    displayLegend: boolean;
    smoothLines: boolean;
    filled: boolean;
    xAxisSettings?: LineChartAxisSettings | undefined;
    yLeftAxisSettings?: LineChartAxisSettings | undefined;
    yRightAxisSettings?: LineChartAxisSettings | undefined;
}

export class LineChartAxisSettings implements ILineChartAxisSettings {
    label?: string | undefined;
    displayLabel!: boolean;
    displayGridLines!: boolean;
    min!: number;
    max!: number;

    constructor(data?: ILineChartAxisSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.displayLabel = _data["displayLabel"];
            this.displayGridLines = _data["displayGridLines"];
            this.min = _data["min"];
            this.max = _data["max"];
        }
    }

    static fromJS(data: any): LineChartAxisSettings {
        data = typeof data === 'object' ? data : {};
        let result = new LineChartAxisSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["displayLabel"] = this.displayLabel;
        data["displayGridLines"] = this.displayGridLines;
        data["min"] = this.min;
        data["max"] = this.max;
        return data; 
    }
}

export interface ILineChartAxisSettings {
    label?: string | undefined;
    displayLabel: boolean;
    displayGridLines: boolean;
    min: number;
    max: number;
}

export class WidgetDetailsVmOfLineChartWidget implements IWidgetDetailsVmOfLineChartWidget {
    widget?: WidgetDto | undefined;
    widgetData?: LineChartWidget | undefined;

    constructor(data?: IWidgetDetailsVmOfLineChartWidget) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.widget = _data["widget"] ? WidgetDto.fromJS(_data["widget"]) : <any>undefined;
            this.widgetData = _data["widgetData"] ? LineChartWidget.fromJS(_data["widgetData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WidgetDetailsVmOfLineChartWidget {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetDetailsVmOfLineChartWidget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widget"] = this.widget ? this.widget.toJSON() : <any>undefined;
        data["widgetData"] = this.widgetData ? this.widgetData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IWidgetDetailsVmOfLineChartWidget {
    widget?: WidgetDto | undefined;
    widgetData?: LineChartWidget | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}